package repogen

import (
	"bytes"
	"fmt"
	"io"
	"regexp"
	"strings"
)

func Generate(t Table) *bytes.Buffer {
	b := bytes.NewBuffer(nil)
	g := &generator{
		t:   t,
		out: b,
	}
	g.header()
	g.createTableStm()
	g.insertStm()
	g.marshal()
	g.unmarshal()
	g.client()
	g.clientCreateTable()
	g.clientInsertMany()
	g.clientGet()
	g.clientList()
	g.clientListIndexes()
	return b
}

type generator struct {
	t   Table
	out io.Writer
}

func (g *generator) p(format string, a ...interface{}) {
	_, _ = fmt.Fprintf(g.out, format, a...)
	_, _ = fmt.Fprintln(g.out)
}

func (g *generator) header() {
	g.p("// Code generated by repogen. DO NOT EDIT.")
	g.p("package %s", g.t.Package)
	g.p("import (")
	g.p(`"database/sql"`)
	g.p(`"time"`)
	g.p(")")
	g.p("var (")
	g.p("_ = time.UTC")
	g.p(")")
}

func (g *generator) createTableStm() {
	g.p("const %s_CreateTableStm = `CREATE TABLE \"%s\" (", g.t.Name, snakeCase(g.t.Name))
	for i, c := range g.t.Columns {
		extra := ""
		if c.NotNull {
			extra += " NOT NULL"
		}
		if c.Primary {
			extra += " PRIMARY KEY"
		}
		if i != len(g.t.Columns)-1 {
			extra += ","
		}
		g.p("\t%s %s%s", snakeCase(c.Name), c.Type, extra)
	}
	g.p(")`")

	for name, columns := range g.t.Indexes() {
		var cnames []string
		for _, col := range columns {
			cnames = append(cnames, snakeCase(col.Name))
		}
		g.p(`const %s_CreateIndexStm_%s = "CREATE INDEX %s ON %s(%s)"`, g.t.Name, name, name, snakeCase(g.t.Name), strings.Join(cnames, ", "))
	}
}

func (g *generator) insertStm() {
	g.p("const %s_InsertStm = `", g.t.Name)
	g.p("INSERT INTO %s (", snakeCase(g.t.Name))
	for i, c := range g.t.Columns {
		extra := ""
		if i != len(g.t.Columns)-1 {
			extra = ","
		}
		g.p("\t%s%s", snakeCase(c.Name), extra)
	}
	g.p(") VALUES (")
	for i, _ := range g.t.Columns {
		extra := ""
		if i != len(g.t.Columns)-1 {
			extra = ","
		}
		g.p("\t?%s", extra)
	}
	g.p(")")
	g.p("`")
}

func (g *generator) marshal() {
	g.p("func (r *%s) MarshalRow() []interface{} {", g.t.Name)
	g.p("return []interface{}{")
	for _, c := range g.t.Columns {
		g.p("r.%s,", c.Name)
	}
	g.p("}")
	g.p("}")
}

func (g *generator) unmarshal() {
	g.p("func (r *%s) UnmarshalRow(row interface{ Scan(...interface{}) error }) error {", g.t.Name)
	g.p("return row.Scan(")
	for _, c := range g.t.Columns {
		g.p("&r.%s,", c.Name)
	}
	g.p(")")
	g.p("}")
}

func (g *generator) client() {
	g.p("type %sRepo struct {", g.t.Name)
	g.p("DB *sql.DB")
	g.p("}")
}

func (g *generator) clientCreateTable() {
	g.p("func (r *%sRepo) CreateTable() error {", g.t.Name)
	g.p("if _, err := r.DB.Exec(%s_CreateTableStm); err != nil { return err }", g.t.Name)
	for name, _ := range g.t.Indexes() {
		g.p("if _, err := r.DB.Exec(%s_CreateIndexStm_%s); err != nil { return err }", g.t.Name, name)
	}
	g.p("return nil")
	g.p("}")
}

func (g *generator) clientInsertMany() {
	g.p("func (r *%sRepo) InsertMany(rs []*%s) error {", g.t.Name, g.t.Name)
	g.p("tx, err := r.DB.Begin()")
	g.p("if err != nil { return err }")
	g.p("stm, err := tx.Prepare(%s_InsertStm)", g.t.Name)
	g.p("if err != nil { return err }")
	g.p("defer stm.Close()")
	g.p("for _, r := range rs {")
	g.p("if _, err := stm.Exec(r.MarshalRow()...); err != nil { return err }")
	g.p("}")
	g.p("if err := tx.Commit(); err != nil { return err }")
	g.p("return nil")
	g.p("}")
}

func (g *generator) clientGet() {
	primary, ok := g.t.PrimaryColumn()
	if !ok {
		return
	}
	g.p("func (r *%sRepo) Get(%s %s) (*%s, error) {", g.t.Name, snakeCase(primary.Name), primary.Type.GoType(), g.t.Name)
	g.p(`row := r.DB.QueryRow("SELECT * FROM %s WHERE %s = ?", %s)`, snakeCase(g.t.Name), snakeCase(primary.Name), snakeCase(primary.Name))
	g.p("var res %s", g.t.Name)
	g.p("if err := res.UnmarshalRow(row); err != nil { return nil, err }")
	g.p("return &res, nil")
	g.p("}")
}

func (g *generator) clientList() {
	g.p("func (r *%sRepo) List(where string, args ...interface{}) ([]*%s, error) {", g.t.Name, g.t.Name)
	g.p(`q := "SELECT * FROM %s"`, snakeCase(g.t.Name))
	g.p(`if where != "" { q += " WHERE " + where }`)
	g.p(`rows, err := r.DB.Query(q, args...)`)
	g.p("if err != nil { return nil, err }")
	g.p("defer rows.Close()")
	g.p("var ress []*%s", g.t.Name)
	g.p("for rows.Next() {")
	g.p("var res %s", g.t.Name)
	g.p("if err := res.UnmarshalRow(rows); err != nil { return nil, err }")
	g.p("ress = append(ress, &res)")
	g.p("}")
	g.p("return ress, nil")
	g.p("}")
}

func (g *generator) clientListIndexes() {
	inds := g.t.Indexes()
	for name, columns := range inds {
		args := ""
		for _, col := range columns {
			args += fmt.Sprintf("%s %s,", snakeCase(col.Name), col.Type.GoType())
		}
		g.p("func (r *%sRepo) List%s(%s) ([]*%s, error) {", g.t.Name, camelCase(name), args, g.t.Name)
		var stmWheres []string
		var stmArgs []string
		for _, col := range columns {
			stmWheres = append(stmWheres, fmt.Sprintf("%s=?", snakeCase(col.Name)))
			stmArgs = append(stmArgs, snakeCase(col.Name))
		}
		g.p(`rows, err := r.DB.Query("SELECT * FROM %s WHERE %s", %s)`, snakeCase(g.t.Name), strings.Join(stmWheres, " AND "), strings.Join(stmArgs, ", "))
		g.p("if err != nil { return nil, err }")
		g.p("defer rows.Close()")
		g.p("var ress []*%s", g.t.Name)
		g.p("for rows.Next() {")
		g.p("var res %s", g.t.Name)
		g.p("if err := res.UnmarshalRow(rows); err != nil { return nil, err }")
		g.p("ress = append(ress, &res)")
		g.p("}")
		g.p("return ress, nil")
		g.p("}")
	}
}

var (
	matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
	matchAllCap   = regexp.MustCompile("([a-z0-9])([A-Z])")
)

func snakeCase(str string) string {
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}

var link = regexp.MustCompile("(^[A-Za-z])|_([A-Za-z])")

func camelCase(str string) string {
	return link.ReplaceAllStringFunc(str, func(s string) string {
		return strings.ToUpper(strings.Replace(s, "_", "", -1))
	})
}
